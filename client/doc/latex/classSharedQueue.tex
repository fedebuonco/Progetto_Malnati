\hypertarget{classSharedQueue}{}\doxysection{Shared\+Queue Class Reference}
\label{classSharedQueue}\index{SharedQueue@{SharedQueue}}


This is the shared queue. Each \mbox{\hyperlink{classFileSipper}{File\+Sipper}} is demanded to send a file. The \mbox{\hyperlink{classSender}{Sender}} decides who starts sending.  




{\ttfamily \#include $<$shared\+\_\+queue.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSharedQueue_a063cbf927b958681fc7b38854f9c0fe6}\label{classSharedQueue_a063cbf927b958681fc7b38854f9c0fe6}} 
{\bfseries Shared\+Queue} (const \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} \&)=delete
\item 
\mbox{\Hypertarget{classSharedQueue_a76c38a2b23a56d2340d910bcc1ea1cd7}\label{classSharedQueue_a76c38a2b23a56d2340d910bcc1ea1cd7}} 
\mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} \& {\bfseries operator=} (const \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} \&)=delete
\item 
void \mbox{\hyperlink{classSharedQueue_a00f207e695c81cc031d0b1b2d551b5c6}{set\+Flag}} (bool flag\+\_\+value)
\begin{DoxyCompactList}\small\item\em Change Shared\+\_\+\+Queue status. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ \mbox{\hyperlink{classSharedQueue_ad45eb5d6394b2aaad80b7c85b7f56404}{get\+\_\+ready\+\_\+\+File\+Sipper}} ()
\begin{DoxyCompactList}\small\item\em Choose a \mbox{\hyperlink{classFileSipper}{File\+Sipper}} from the queue that is ready to send a file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classSharedQueue_a0844701624f2f3efc31a94c3f256dcfe}{remove\+\_\+element}} (const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ \&file\+\_\+sipper)
\begin{DoxyCompactList}\small\item\em Remove the selected file\+Sipper from the shared queue. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classSharedQueue_a6f73bdb6748280fb66f0ec17127b7b6d}{insert}} (std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ file\+\_\+sipper)
\begin{DoxyCompactList}\small\item\em Add a new ptr\+File\+Sipper in the \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} $\ast$ \mbox{\hyperlink{classSharedQueue_acd3b0485590cdcd76b1e79fb0079e426}{get\+\_\+\+Instance}} ()
\begin{DoxyCompactList}\small\item\em Get method for singletone instance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSharedQueue_ada82bb150ec958df0b78b85da2947200}\label{classSharedQueue_ada82bb150ec958df0b78b85da2947200}} 
std\+::list$<$ std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ $>$ \mbox{\hyperlink{classSharedQueue_ada82bb150ec958df0b78b85da2947200}{fs\+\_\+list}}
\begin{DoxyCompactList}\small\item\em List of all shared\+\_\+ptr to File\+Sippers. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSharedQueue_a906257eb3c2a9be5f86823468f6af7ea}\label{classSharedQueue_a906257eb3c2a9be5f86823468f6af7ea}} 
std\+::mutex \mbox{\hyperlink{classSharedQueue_a906257eb3c2a9be5f86823468f6af7ea}{m}}
\begin{DoxyCompactList}\small\item\em Protect shared list (fs\+\_\+list) from being simultaneously accessed by multiple threads. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSharedQueue_a30b2e6b8ffc83627f8f8296748de520f}\label{classSharedQueue_a30b2e6b8ffc83627f8f8296748de520f}} 
std\+::condition\+\_\+variable \mbox{\hyperlink{classSharedQueue_a30b2e6b8ffc83627f8f8296748de520f}{cv}}
\begin{DoxyCompactList}\small\item\em Condition Variable in order to block other threads. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSharedQueue_a00fed154691598d2dea8c4f6e7e0e5cf}\label{classSharedQueue_a00fed154691598d2dea8c4f6e7e0e5cf}} 
std\+::atomic$<$ int $>$ \mbox{\hyperlink{classSharedQueue_a00fed154691598d2dea8c4f6e7e0e5cf}{active\+\_\+fs}} = 0
\begin{DoxyCompactList}\small\item\em Active file\+Sipper counter (file\+Sipper assigned to a thread of the pool) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classSharedQueue_ae697c571d6de8b0989c1091e561a74d0}\label{classSharedQueue_ae697c571d6de8b0989c1091e561a74d0}} 
std\+::atomic$<$ bool $>$ \mbox{\hyperlink{classSharedQueue_ae697c571d6de8b0989c1091e561a74d0}{flag}} = true
\begin{DoxyCompactList}\small\item\em Shutdown flag. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSharedQueue_ac88fc77603cef320269404282bb95a95}\label{classSharedQueue_ac88fc77603cef320269404282bb95a95}} 
static \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} $\ast$ \mbox{\hyperlink{classSharedQueue_ac88fc77603cef320269404282bb95a95}{m\+\_\+\+Shared\+Queue}} = nullptr
\begin{DoxyCompactList}\small\item\em Singletone pointer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is the shared queue. Each \mbox{\hyperlink{classFileSipper}{File\+Sipper}} is demanded to send a file. The \mbox{\hyperlink{classSender}{Sender}} decides who starts sending. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classSharedQueue_acd3b0485590cdcd76b1e79fb0079e426}\label{classSharedQueue_acd3b0485590cdcd76b1e79fb0079e426}} 
\index{SharedQueue@{SharedQueue}!get\_Instance@{get\_Instance}}
\index{get\_Instance@{get\_Instance}!SharedQueue@{SharedQueue}}
\doxysubsubsection{\texorpdfstring{get\_Instance()}{get\_Instance()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} $\ast$ Shared\+Queue\+::get\+\_\+\+Instance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Get method for singletone instance. 

\begin{DoxyReturn}{Returns}
tr to \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classSharedQueue_ad45eb5d6394b2aaad80b7c85b7f56404}\label{classSharedQueue_ad45eb5d6394b2aaad80b7c85b7f56404}} 
\index{SharedQueue@{SharedQueue}!get\_ready\_FileSipper@{get\_ready\_FileSipper}}
\index{get\_ready\_FileSipper@{get\_ready\_FileSipper}!SharedQueue@{SharedQueue}}
\doxysubsubsection{\texorpdfstring{get\_ready\_FileSipper()}{get\_ready\_FileSipper()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ Shared\+Queue\+::get\+\_\+ready\+\_\+\+File\+Sipper (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Choose a \mbox{\hyperlink{classFileSipper}{File\+Sipper}} from the queue that is ready to send a file. 

If queue is empty or all \mbox{\hyperlink{classFileSipper}{File\+Sipper}} are already started, \mbox{\hyperlink{classSender}{Sender}} will be waiting. \begin{DoxyReturn}{Returns}
shared ptr to selected file\+Sipper, or nullptr if error occured 
\end{DoxyReturn}
\mbox{\Hypertarget{classSharedQueue_a6f73bdb6748280fb66f0ec17127b7b6d}\label{classSharedQueue_a6f73bdb6748280fb66f0ec17127b7b6d}} 
\index{SharedQueue@{SharedQueue}!insert@{insert}}
\index{insert@{insert}!SharedQueue@{SharedQueue}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily void Shared\+Queue\+::insert (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$}]{file\+\_\+sipper }\end{DoxyParamCaption})}



Add a new ptr\+File\+Sipper in the \mbox{\hyperlink{classSharedQueue}{Shared\+Queue}}. 


\begin{DoxyParams}{Parameters}
{\em file\+\_\+sipper} & \+: ptr to the file\+Sipper to be added \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classSharedQueue_a0844701624f2f3efc31a94c3f256dcfe}\label{classSharedQueue_a0844701624f2f3efc31a94c3f256dcfe}} 
\index{SharedQueue@{SharedQueue}!remove\_element@{remove\_element}}
\index{remove\_element@{remove\_element}!SharedQueue@{SharedQueue}}
\doxysubsubsection{\texorpdfstring{remove\_element()}{remove\_element()}}
{\footnotesize\ttfamily void Shared\+Queue\+::remove\+\_\+element (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classFileSipper}{File\+Sipper}} $>$ \&}]{file\+\_\+sipper }\end{DoxyParamCaption})}



Remove the selected file\+Sipper from the shared queue. 


\begin{DoxyParams}{Parameters}
{\em file\+\_\+sipper} & \+: ptr to the file\+Sipper to be removed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classSharedQueue_a00f207e695c81cc031d0b1b2d551b5c6}\label{classSharedQueue_a00f207e695c81cc031d0b1b2d551b5c6}} 
\index{SharedQueue@{SharedQueue}!setFlag@{setFlag}}
\index{setFlag@{setFlag}!SharedQueue@{SharedQueue}}
\doxysubsubsection{\texorpdfstring{setFlag()}{setFlag()}}
{\footnotesize\ttfamily void Shared\+Queue\+::set\+Flag (\begin{DoxyParamCaption}\item[{bool}]{flag\+\_\+value }\end{DoxyParamCaption})}



Change Shared\+\_\+\+Queue status. 

If false the program will shutdown gracefully 
\begin{DoxyParams}{Parameters}
{\em flag\+\_\+value} & new flag value \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
includes/client/shared\+\_\+queue.\+h\item 
src/client/shared\+\_\+queue.\+cpp\end{DoxyCompactItemize}
